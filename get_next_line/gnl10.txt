MATH(3)                  BSD Library Functions Manual                  MATH(3)NNAAMMEE     mmaatthh -- mathematical library functionsSSYYNNOOPPSSIISS     ##iinncclluuddee <<mmaatthh..hh>>DDEESSCCRRIIPPTTIIOONN     The header file math.h provides function prototypes and macros for work-     ing with floating point values.     Each math.h function is provided in three variants: single, double and     extended precision.  The single and double precision variants operate on     IEEE-754 single and double precision values, which correspond to the C     types _f_l_o_a_t and _d_o_u_b_l_e, respectively.     On Intel Macs, the C type _l_o_n_g _d_o_u_b_l_e corresponds to 80-bit IEEE-754 dou-     ble extended precision.  On iOS devices using ARM processors, _l_o_n_g _d_o_u_b_l_e     is mapped to _d_o_u_b_l_e, as there is no hardware-supported wider type.     Details of the floating point formats can be found via "man float".     Users who need to repeatedly perform the same calculation on a large set     of data will probably find that the vector math library (composed of     vMathLib and vForce) yields better performance for their needs than     sequential calls to the libm.     Users who need to perform mathematical operations on complex floating-     point numbers should consult the man pages for the complex portion of the     math library, via "man complex".LLIISSTT OOFF FFUUNNCCTTIIOONNSS     Each of the functions that use floating-point values are provided in sin-     gle, double, and extended precision; the double precision prototypes are     listed here.  The man pages for the individual functions provide more     details on their use, special cases, and prototypes for their single and     extended precision versions.     _i_n_t ffppccllaassssiiffyy(_d_o_u_b_l_e)     _i_n_t iissffiinniittee(_d_o_u_b_l_e)     _i_n_t iissiinnff(_d_o_u_b_l_e)     _i_n_t iissnnaann(_d_o_u_b_l_e)     _i_n_t iissnnoorrmmaall(_d_o_u_b_l_e)     _i_n_t ssiiggnnbbiitt(_d_o_u_b_l_e)     These function-like macros are used to classify a single floating-point     argument.     _d_o_u_b_l_e ccooppyyssiiggnn(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e nneexxttaafftteerr(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ccooppyyssiiggnn(_x_, _y) returns the value equal in magnitude to _x with the sign of     _y.  nneexxttaafftteerr(_x_, _y) returns the next floating-point number after _x in the     direction of _y.  Both are correctly-rounded.     _d_o_u_b_l_e nnaann(_c_o_n_s_t _c_h_a_r _*_t_a_g)     The nnaann() function returns a quiet NaN, without raising the invalid flag.     _d_o_u_b_l_e cceeiill(_d_o_u_b_l_e)     _d_o_u_b_l_e fflloooorr(_d_o_u_b_l_e)     _d_o_u_b_l_e nneeaarrbbyyiinntt(_d_o_u_b_l_e)     _d_o_u_b_l_e rriinntt(_d_o_u_b_l_e)     _d_o_u_b_l_e rroouunndd(_d_o_u_b_l_e)     _l_o_n_g _i_n_t llrriinntt(_d_o_u_b_l_e)     _l_o_n_g _i_n_t llrroouunndd(_d_o_u_b_l_e)     _l_o_n_g _l_o_n_g _i_n_t llllrriinntt(_d_o_u_b_l_e)     _l_o_n_g _l_o_n_g _i_n_t llllrroouunndd(_d_o_u_b_l_e)     _d_o_u_b_l_e ttrruunncc(_d_o_u_b_l_e)     These functions provide various means to round floating-point values to     integral values.  They are correctly rounded.     _d_o_u_b_l_e ffmmoodd(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e rreemmaaiinnddeerr(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e rreemmqquuoo(_d_o_u_b_l_e _x_, _d_o_u_b_l_e _y_, _i_n_t _*)     These return a remainder of the division of x by y with an integral quo-     tient.  rreemmqquuoo() additionally provides access to a few lower bits of the     quotient.  They are correctly rounded.     _d_o_u_b_l_e ffddiimm(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e ffmmaaxx(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e ffmmiinn(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ffmmaaxx(_x_, _y) and ffmmiinn(_x_, _y) return the maximum and minimum of _x and _y,     respectively.  ffddiimm(_x_, _y) returns the positive difference of _x and _y. _A_l_l     _a_r_e _c_o_r_r_e_c_t_l_y _r_o_u_n_d_e_d_.     _d_o_u_b_l_e ffmmaa(_d_o_u_b_l_e _x_, _d_o_u_b_l_e _y_, _d_o_u_b_l_e _z)     ffmmaa(_x_, _y_, _z) computes the value (x*y) + z as though without intermediate     rounding.  It is correctly rounded.     _d_o_u_b_l_e ffaabbss(_d_o_u_b_l_e)     _d_o_u_b_l_e ssqqrrtt(_d_o_u_b_l_e)     _d_o_u_b_l_e ccbbrrtt(_d_o_u_b_l_e)     _d_o_u_b_l_e hhyyppoott(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ffaabbss(_x), ssqqrrtt(_x), and ccbbrrtt(_x) return the absolute value, square root, and     cube root of _x, respectively.  hhyyppoott(_x_, _y) returns sqrt(x*x + y*y).     ffaabbss() and ssqqrrtt() are correctly rounded.     _d_o_u_b_l_e eexxpp(_d_o_u_b_l_e)     _d_o_u_b_l_e eexxpp22(_d_o_u_b_l_e)     _d_o_u_b_l_e ____eexxpp1100(_d_o_u_b_l_e)     _d_o_u_b_l_e eexxppmm11(_d_o_u_b_l_e)     eexxpp(_x), eexxpp22(_x), ____eexxpp1100(_x), and eexxppmm11(_x) return e**x, 2**x, 10**x, and     e**x - 1, respectively.     _d_o_u_b_l_e lloogg(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg22(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg1100(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg11pp(_d_o_u_b_l_e)     lloogg(_x), lloogg22(_x), and lloogg1100(_x) return the natural, base-2, and base-10     logarithms of _x, respectively.  lloogg11pp(_x) returns the natural log of 1+x.     _d_o_u_b_l_e llooggbb(_d_o_u_b_l_e)     _i_n_t iillooggbb(_d_o_u_b_l_e)     llooggbb(_x) and iillooggbb(_x) return the exponent of _x.     _d_o_u_b_l_e mmooddff(_d_o_u_b_l_e_, _d_o_u_b_l_e _*)     _d_o_u_b_l_e ffrreexxpp(_d_o_u_b_l_e_, _i_n_t _*)     mmooddff(_x_, _&_y) returns the fractional part of _x and stores the integral part     in _y.  ffrreexxpp(_x_, _&_n) returns the mantissa of _x and stores the exponent in     _n. _T_h_e_y _a_r_e _c_o_r_r_e_c_t_l_y _r_o_u_n_d_e_d_.     _d_o_u_b_l_e llddeexxpp(_d_o_u_b_l_e_, _i_n_t)     _d_o_u_b_l_e ssccaallbbnn(_d_o_u_b_l_e_, _i_n_t)     _d_o_u_b_l_e ssccaallbbllnn(_d_o_u_b_l_e_, _l_o_n_g _i_n_t)     llddeexxpp(_x_, _n), ssccaallbbnn(_x_, _n), and ssccaallbbllnn(_x_, _n) return x*2**n.  They are     correctly rounded.     _d_o_u_b_l_e ppooww(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ppooww(_x_,_y) returns x raised to the power y.     _d_o_u_b_l_e ccooss(_d_o_u_b_l_e)     _d_o_u_b_l_e ssiinn(_d_o_u_b_l_e)     _d_o_u_b_l_e ttaann(_d_o_u_b_l_e)     ccooss(_x), ssiinn(_x), and ttaann(_x) return the cosine, sine and tangent of _x,     respectively.  Note that _x is interpreted as specifying an angle in radi-     ans.     _d_o_u_b_l_e ccoosshh(_d_o_u_b_l_e)     _d_o_u_b_l_e ssiinnhh(_d_o_u_b_l_e)     _d_o_u_b_l_e ttaannhh(_d_o_u_b_l_e)     ccoosshh(_x), ssiinnhh(_x), and ttaannhh(_x) return the hyperbolic cosine, hyperbolic     sine and hyperbolic tangent of _x, respectively.     _d_o_u_b_l_e aaccooss(_d_o_u_b_l_e)     _d_o_u_b_l_e aassiinn(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaann(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaann22(_d_o_u_b_l_e_, _d_o_u_b_l_e)     aaccooss(_x), aassiinn(_x), and aattaann(_x) return the inverse cosine, inverse sine and     inverse tangent of _x, respectively.  Note that the result is an angle in     radians.  aattaann22(_y_, _x) returns the inverse tangent of y/x in radians, with     sign chosen according to the quadrant of (x,y).     _d_o_u_b_l_e aaccoosshh(_d_o_u_b_l_e)     _d_o_u_b_l_e aassiinnhh(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaannhh(_d_o_u_b_l_e)     aaccoosshh(_x), aassiinnhh(_x), and aattaannhh(_x) return the inverse hyperbolic cosine,     inverse hyperbolic sine and inverse hyperbolic tangent of _x, respec-     tively.     _d_o_u_b_l_e ttggaammmmaa(_d_o_u_b_l_e)     _d_o_u_b_l_e llggaammmmaa(_d_o_u_b_l_e)     ttggaammmmaa(_x) and llggaammmmaa(_x) return the values of the gamma function and its     logarithm evalutated at _x, respectively.     _d_o_u_b_l_e jj00(_d_o_u_b_l_e)     _d_o_u_b_l_e jj11(_d_o_u_b_l_e)     _d_o_u_b_l_e jjnn(_i_n_t, _d_o_u_b_l_e)     _d_o_u_b_l_e yy00(_d_o_u_b_l_e)     _d_o_u_b_l_e yy11(_d_o_u_b_l_e)     _d_o_u_b_l_e yynn(_i_n_t, _d_o_u_b_l_e)     jj00(_x), jj11(_x), and jjnn(_x) return the values of the zeroth, first, and nth     Bessel function of the first kind evaluated at _x, respectively.  yy00(_x),     yy11(_x), and yynn(_x) return the values of the zeroth, first, and nth Bessel     function of the second kind evaluated at _x, respectively.     _d_o_u_b_l_e eerrff(_d_o_u_b_l_e)     _d_o_u_b_l_e eerrffcc(_d_o_u_b_l_e)     eerrff(_x) and eerrffcc(_x) return the values of the error function and the com-     plementary error function evaluated at _x, respectively.MMAATTHHEEMMAATTIICCAALL CCOONNSSTTAANNTTSS     In addition to the functions listed above, math.h defines a number of     useful constants, listed below.     CONSTANT        VALUE     M_E             base of natural logarithm, e     M_LOG2E         log2(e)     M_LOG10E        log10(e)     M_LN2           ln(2)     M_LN10          ln(10)     M_PI            pi     M_PI_2          pi / 2     M_PI_4          pi / 4     M_1_PI          1 / pi     M_2_PI          2 / pi     M_2_SQRTPI      2 / sqrt(pi)     M_SQRT2         sqrt(2)     M_SQRT1_2       sqrt(1/2)IIEEEEEE SSTTAANNDDAARRDD 775544 FFLLOOAATTIINNGG--PPOOIINNTT AARRIITTHHMMEETTIICC     The libm functions declared in math.h provide mathematical library func-     tions in single-, double-, and extended-precision IEEE-754 floating-point     formats on Intel macs, and in single- and double-precision IEEE-754     floating-point formats on PowerPC macs.SSEEEE AALLSSOO     float(3), complex(3)SSTTAANNDDAARRDDSS     The <math.h> functions conform to the ISO/IEC 9899:2011 standard.BSD                             August 16, 2012                            BSD
Â© 2019 G
